"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path = require("path");
const util = require("util");
const minimist = require("minimist");
const chalk = require("chalk");
const cli_utils_1 = require("@ionic/cli-utils");
const commands_1 = require("./commands");
const init_1 = require("./lib/init");
exports.name = 'ionic';
exports.version = '3.7.0';
exports.namespace = new commands_1.IonicNamespace();
exports.meta = { filePath: __filename };
const BUILD_BEFORE_HOOK = 'build:before';
const BUILD_BEFORE_SCRIPT = `ionic:${BUILD_BEFORE_HOOK}`;
const BUILD_AFTER_HOOK = 'build:after';
const BUILD_AFTER_SCRIPT = `ionic:${BUILD_AFTER_HOOK}`;
const WATCH_BEFORE_HOOK = 'watch:before';
const WATCH_BEFORE_SCRIPT = `ionic:${WATCH_BEFORE_HOOK}`;
function registerHooks(hooks) {
    hooks.register(exports.name, BUILD_BEFORE_HOOK, ({ env }) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const packageJson = yield env.project.loadPackageJson();
        if (packageJson.scripts && packageJson.scripts[BUILD_BEFORE_SCRIPT]) {
            env.log.debug(() => `Invoking ${chalk.cyan(BUILD_BEFORE_SCRIPT)} npm script.`);
            yield env.shell.run('npm', ['run', BUILD_BEFORE_SCRIPT], { showExecution: true });
        }
    }));
    hooks.register(exports.name, BUILD_AFTER_HOOK, ({ env }) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const packageJson = yield env.project.loadPackageJson();
        if (packageJson.scripts && packageJson.scripts[BUILD_AFTER_SCRIPT]) {
            env.log.debug(() => `Invoking ${chalk.cyan(BUILD_AFTER_SCRIPT)} npm script.`);
            yield env.shell.run('npm', ['run', BUILD_AFTER_SCRIPT], { showExecution: true });
        }
    }));
    hooks.register(exports.name, WATCH_BEFORE_HOOK, ({ env }) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const packageJson = yield env.project.loadPackageJson();
        if (packageJson.scripts && packageJson.scripts[WATCH_BEFORE_SCRIPT]) {
            env.log.debug(() => `Invoking ${chalk.cyan(WATCH_BEFORE_SCRIPT)} npm script.`);
            yield env.shell.run('npm', ['run', WATCH_BEFORE_SCRIPT], { showExecution: true });
        }
    }));
    hooks.register(exports.name, 'command:info', () => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const osName = yield Promise.resolve().then(function () { return require('os-name'); });
        const os = osName();
        const node = process.version;
        const { getAndroidSdkToolsVersion } = yield Promise.resolve().then(function () { return require('./lib/android'); });
        const [npm, xcode, iosDeploy, iosSim, androidSdkToolsVersion,] = yield Promise.all([
            cli_utils_1.getCommandInfo('npm', ['-v']),
            cli_utils_1.getCommandInfo('/usr/bin/xcodebuild', ['-version']),
            cli_utils_1.getCommandInfo('ios-deploy', ['--version']),
            cli_utils_1.getCommandInfo('ios-sim', ['--version']),
            getAndroidSdkToolsVersion(),
        ]);
        const info = [
            { type: 'cli-packages', name: `${exports.name} ${chalk.dim('(Ionic CLI)')}`, version: exports.version, path: path.dirname(path.dirname(__filename)) },
            { type: 'system', name: 'Node', version: node },
            { type: 'system', name: 'npm', version: npm || 'not installed' },
            { type: 'system', name: 'OS', version: os },
        ];
        if (xcode) {
            info.push({ type: 'system', name: 'Xcode', version: xcode });
        }
        if (iosDeploy) {
            info.push({ type: 'system', name: 'ios-deploy', version: iosDeploy });
        }
        if (iosSim) {
            info.push({ type: 'system', name: 'ios-sim', version: iosSim });
        }
        if (androidSdkToolsVersion) {
            info.push({ type: 'system', name: 'Android SDK Tools', version: androidSdkToolsVersion });
        }
        return info;
    }));
}
exports.registerHooks = registerHooks;
function run(pargv, env) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const now = new Date();
        let exitCode = 0;
        let err;
        pargv = init_1.modifyArguments(pargv.slice(2));
        env['IONIC_CLI_LIB'] = __filename;
        const ienv = yield cli_utils_1.generateIonicEnvironment(exports, pargv, env);
        try {
            const config = yield ienv.config.load();
            registerHooks(ienv.hooks);
            ienv.log.debug(() => util.inspect(ienv.meta, { breakLength: Infinity, colors: chalk.enabled }));
            if (env['IONIC_EMAIL'] && env['IONIC_PASSWORD']) {
                ienv.log.debug(() => `${chalk.bold('IONIC_EMAIL')} / ${chalk.bold('IONIC_PASSWORD')} environment variables detected`);
                if (config.user.email !== env['IONIC_EMAIL']) {
                    ienv.log.debug(() => `${chalk.bold('IONIC_EMAIL')} mismatch with current session--attempting login`);
                    try {
                        yield ienv.session.login(env['IONIC_EMAIL'], env['IONIC_PASSWORD']);
                    }
                    catch (e) {
                        ienv.log.error(`Error occurred during automatic login via ${chalk.bold('IONIC_EMAIL')} / ${chalk.bold('IONIC_PASSWORD')} environment variables.`);
                        throw e;
                    }
                }
            }
            if (ienv.project.directory) {
                const nodeModulesExists = yield cli_utils_1.pathExists(path.join(ienv.project.directory, 'node_modules'));
                if (!nodeModulesExists) {
                    const confirm = yield ienv.prompt({
                        type: 'confirm',
                        name: 'confirm',
                        message: `Looks like a fresh checkout! No ${chalk.green('./node_modules')} directory found. Would you like to install project dependencies?`,
                    });
                    if (confirm) {
                        ienv.log.info('Installing dependencies may take several minutes!');
                        const [installer, ...installerArgs] = yield cli_utils_1.pkgManagerArgs(ienv, { command: 'install' });
                        yield ienv.shell.run(installer, installerArgs, {});
                    }
                }
            }
            const argv = minimist(pargv, { boolean: true, string: '_' });
            // If an legacy command is being executed inform the user that there is a new command available
            const foundCommand = init_1.mapLegacyCommand(argv._[0]);
            if (foundCommand) {
                ienv.log.msg(`The ${chalk.green(argv._[0])} command has been renamed. To find out more, run:\n\n` +
                    `  ${chalk.green(`ionic ${foundCommand} --help`)}\n\n`);
            }
            else {
                try {
                    yield cli_utils_1.loadPlugins(ienv);
                }
                catch (e) {
                    if (e.fatal) {
                        throw e;
                    }
                    ienv.log.error(chalk.red.bold('Error occurred while loading plugins. CLI functionality may be limited.'));
                    ienv.log.debug(() => chalk.red(chalk.bold('Plugin error: ') + (e.stack ? e.stack : e)));
                }
                if (ienv.flags.interactive) {
                    if (typeof config.daemon.updates === 'undefined') {
                        const confirm = yield ienv.prompt({
                            type: 'confirm',
                            name: 'confirm',
                            message: `The Ionic CLI can automatically check for CLI updates in the background. Would you like to enable this?`,
                        });
                        config.daemon.updates = confirm;
                        yield ienv.config.save();
                    }
                    if (config.daemon.updates) {
                        yield Promise.all([cli_utils_1.checkForDaemon(ienv), cli_utils_1.checkForUpdates(ienv)]);
                    }
                }
                yield ienv.hooks.fire('plugins:init', { env: ienv });
                const r = yield exports.namespace.runCommand(ienv, pargv);
                if (typeof r === 'number') {
                    exitCode = r;
                }
                config.lastCommand = now.toISOString();
            }
        }
        catch (e) {
            err = e;
        }
        try {
            yield Promise.all([
                ienv.config.save(),
                ienv.project.save(),
                ienv.daemon.save(),
            ]);
        }
        catch (e) {
            ienv.log.error(e);
        }
        if (err) {
            ienv.tasks.fail();
            exitCode = 1;
            if (cli_utils_1.isValidationErrorArray(err)) {
                for (let e of err) {
                    ienv.log.error(e.message);
                }
                ienv.log.msg(`Use the ${chalk.green('--help')} flag for more details.`);
            }
            else if (cli_utils_1.isSuperAgentError(err)) {
                ienv.log.msg(cli_utils_1.formatSuperAgentError(err));
            }
            else if (err.fatal) {
                exitCode = typeof err.exitCode === 'number' ? err.exitCode : 1;
                if (err.message) {
                    if (exitCode > 0) {
                        ienv.log.error(err.message);
                    }
                    else {
                        ienv.log.msg(err.message);
                    }
                }
            }
            else {
                ienv.log.msg(chalk.red(String(err)));
                if (err.stack) {
                    ienv.log.debug(() => chalk.red(err.stack));
                }
            }
        }
        ienv.close();
        if (exitCode > 0) {
            process.exit(exitCode);
        }
    });
}
exports.run = run;
